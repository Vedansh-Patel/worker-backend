
/**
 * Worker process:
 * - Listens to BullMQ queue 'jobs'
 * - For each job: get plan from Gemini (or mock), serialize using Handlebars templates,
 *   zip the output, and update the Job record in Prisma.
 */

const { Worker, QueueScheduler } = require('bullmq');
const IORedis = require('ioredis');
const path = require('path');
const fs = require('fs');
const { PrismaClient } = require('@prisma/client');
const Handlebars = require('handlebars');
const archiver = require('archiver');
const fetch = require('node-fetch');

const prisma = new PrismaClient();
const redis = new IORedis(process.env.REDIS_URL || 'redis://127.0.0.1:6379');

// Ensure artifacts dir exists
const ARTIFACTS_DIR = path.join(__dirname, '..', 'artifacts');
if (!fs.existsSync(ARTIFACTS_DIR)) fs.mkdirSync(ARTIFACTS_DIR, { recursive: true });

// Queue scheduler required for delayed/retry jobs
new QueueScheduler('jobs', { connection: redis });

async function planWithGemini(idea, platform) {
  const key = process.env.GEMINI_API_KEY;
  if (!key) {
    // Mock plan when no key provided
    return {
      title: idea,
      platform,
      screens: [
        { name: 'Home', components: [{ type: 'text', props: { text: 'Welcome to ' + idea } }] },
        { name: 'About', components: [{ type: 'text', props: { text: 'Generated by mobile-magic-proto' } }] }
      ]
    };
  }

  // Example HTTP call for Gemini Flash - placeholder.
  // Replace with the provider's exact API and auth method you have access to.
  console.log('Calling Gemini (placeholder)');
  const resp = await fetch('https://api.example.com/gemini/flash', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + key },
    body: JSON.stringify({ prompt: `Create a structured plan for: ${idea}` })
  });
  const data = await resp.json();
  // Expect data.plan to be structured as the mock above.
  return data.plan || {
    title: idea,
    platform,
    screens: [{ name: 'Home', components: [{ type: 'text', props: { text: idea } }] }]
  };
}

function zipFolder(srcDir, outPath) {
  return new Promise((resolve, reject) => {
    const output = fs.createWriteStream(outPath);
    const archive = archiver('zip', { zlib: { level: 9 } });
    output.on('close', () => resolve());
    archive.on('error', err => reject(err));
    archive.pipe(output);
    archive.directory(srcDir, false);
    archive.finalize();
  });
}

async function serializeAndWrite(plan, jobId) {
  const tmpDir = path.join(__dirname, '..', 'tmp', 'job-' + jobId);
  if (fs.existsSync(tmpDir)) fs.rmSync(tmpDir, { recursive: true, force: true });
  fs.mkdirSync(tmpDir, { recursive: true });

  // Copy template for platform 'web'
  const tplDir = path.join(__dirname, '..', 'templates', plan.platform);
  if (!fs.existsSync(tplDir)) throw new Error('Template missing: ' + tplDir);
  fs.cpSync(tplDir, tmpDir, { recursive: true });

  // Render index.html with Handlebars
  const indexFile = path.join(tmpDir, 'index.html');
  if (fs.existsSync(indexFile)) {
    const src = fs.readFileSync(indexFile, 'utf8');
    const tpl = Handlebars.compile(src);
    const out = tpl(plan);
    fs.writeFileSync(indexFile, out, 'utf8');
  }

  // write plan for inspection
  fs.writeFileSync(path.join(tmpDir, 'plan.json'), JSON.stringify(plan, null, 2));

  const artifactPath = path.join(ARTIFACTS_DIR, `artifact_${jobId}.zip`);
  await zipFolder(tmpDir, artifactPath);
  return artifactPath;
}

const worker = new Worker('jobs', async job => {
  console.log('Processing job', job.data.jobId);
  const jobId = job.data.jobId;
  await prisma.job.update({ where: { id: jobId }, data: { status: 'processing' } });

  try {
    const dbJob = await prisma.job.findUnique({ where: { id: jobId } });
    const plan = await planWithGemini(dbJob.idea, dbJob.platform);
    const artifactPath = await serializeAndWrite(plan, jobId);
    await prisma.job.update({ where: { id: jobId }, data: { status: 'done', artifactPath } });
    console.log('Job done', jobId);
  } catch (err) {
    console.error('Job failed', err);
    await prisma.job.update({ where: { id: jobId }, data: { status: 'failed' } });
  }
}, { connection: redis });

worker.on('completed', job => console.log('Worker completed job', job.id));
worker.on('failed', (job, err) => console.log('Worker failed', job.id, err));
